digraph "Diagram ObjectValidator [Package org:opencrx:kernel:code1]" {

	graph[
	  splines=ortho;
	];
	node[
		shape=record,
		style=filled,
		fillcolor="#FFFFCB",
		color="#A52A2A",
		fontname="Arial",
		fontsize="10px"
	];
	edge[
		dir=both,
		arrowhead=empty,
		color="#A52A2A",
		fontname="Arial",
		fontsize="10px"
	];
	{
	  rank=same;
	  LAYER0[style=invis];
	  ${CLASS[name=org:opencrx:kernel:code1:Segment,compartments=false,width=3]};
	}
	{
	  rank=same;
	  LAYER1[style=invis];
	  ${CLASS[name=org:opencrx:kernel:code1:ObjectValidator,compartments=true,width=7]};
	}
	{
	  rank=same;
	  LAYER2[style=invis];
	  ${CLASS[name=org:opencrx:kernel:code1:ValidatorCondition,compartments=true,width=7]};
	}
	{
	  rank=same;
	  LAYER3[style=invis];
	  ${CLASS[name=org:opencrx:kernel:code1:ComplexValidatorCondition,compartments=true]};
	  ${CLASS[name=org:opencrx:kernel:code1:BasicValidatorCondition,compartments=true]};
	}
	{
	  rank=same;
	  LAYER4[style=invis];
	  ${CLASS[name=org:openmdx:base:ExtentCapable,compartments=false,fillcolor="#FFBD9D",width=3]};
	  ${CLASS[name=org:openmdx:base:ContextCapable,compartments=false,fillcolor="#FFBD9D",width=3]};
	}
	{
	  rank=same;
	  LAYER5[style=invis];
	  ${CLASS[name=org:opencrx:kernel:code1:ValidateObjectParams,compartments=true,fillcolor="#FFECFF",width=3]};
	  ${CLASS[name=org:opencrx:kernel:code1:ValidateObjectResult,compartments=true,fillcolor="#FFECFF",width=3]};
	}
	{
	  rank=same;
	  LAYER6[style=invis];
	  NOTE0[label="{validateObject() works an a given object as follows:\l* evaluate ::mainCondition recursively\l* if condition is of type ComplexValidatorCondition evaluate all operands and apply ::operator (AND, OR)\l* if condition is of type BasicValidatorCondition evaluate as follows:\l - execute ::query → «list» ContextCapable\l  - for each of these objects get the feature value defined by ::featurePath. The format of ::featurePath is a «.»-separated list of feature names,\l&nbsp;&nbsp;&nbsp;e.g. «activityNumber», «processState.name». The values are retrieved with .refGetValue(featureName). If the (intermediate) value is of type\l&nbsp;&nbsp;&nbsp;RefObject it is matched against ::scope. If the value is not in ::scope it is ignored. The values are sorted by ::scope.\l  - apply ::aggregateFunction (count, sum, min, max, stringify, ...) on these values which results in a value of primitive type.\l  - apply ::condition (equalTo, lessThan, greaterThan, between, matches, ...) with ::conditionParameter.\l}",fillcolor="#D8F2FA"];
	}
	
	LAYER0->LAYER1[style=invis];
	LAYER1->LAYER2[style=invis];
	LAYER2->LAYER3[style=invis];	
	LAYER3->LAYER4[style=invis];
	LAYER4->LAYER5[style=invis];
	LAYER5->LAYER6[style=invis];
	
	${ASSOCIATION[name=org:opencrx:kernel:code1:SegmentContainsObjectValidator,minlen=3]}
	${ASSOCIATION[name=org:opencrx:kernel:code1:ObjectValidatorContainsValidatorCondition,minlen=3]}
	${ASSOCIATION[name=org:opencrx:kernel:code1:BasicValidatorConditionHasScope,minlen=3]}
	${ASSOCIATION[name=*]}
	${INSTANCE_OF}

}
